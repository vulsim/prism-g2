{
  "name": "fsmjs",
  "description": "State machines are back",
  "main": "./main",
  "author": {
    "name": "Elad Ben-Israel",
    "email": "elad.benisrael@gmail.com"
  },
  "version": "0.2.1",
  "contributors": [],
  "keywords": [
    "fsm",
    "state",
    "async",
    "state machine"
  ],
  "dependencies": {},
  "license": "MIT",
  "engines": {
    "node": ">=0.6.6"
  },
  "devDependencies": {
    "nodeunit": "0.6.x",
    "logule": "0.5.x"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/eladb/node-fsmjs"
  },
  "scripts": {
    "test": "nodeunit test/*.test.js"
  },
  "readme": "# fsmjs #\n\n[![Build Status](https://secure.travis-ci.org/anodejs/node-fsmjs.png)](http://travis-ci.org/anodejs/node-fsmjs)\n\nState machines are back, the async way!\n\n```bash\n$ npm install fsmjs\n```\n\n## By example ##\n\n```js\nvar fsmjs = require('../lib/fsmjs');\n\nvar tim = fsmjs({\n\n\tidle: {\n\n\t\t// when 'go' or 'start' or 'g' are pushed, we move to 'running' and start\n\t\t// an interval that emits a 'tick' event every 100ms.\n\t\t'(go|start|g)': function(cb) {\n\t\t\tprocess.stdout.write('starting engines...\\n');\n\t\t\ttim.state = 'running'; \n\t\t\ttim._timer = tim.interval('tick', 100);\n\t\t\tcb();\n\t\t},\n\n\t\t// strings are target states (and emitted events)\n\t\texit: 'end',\n\t\te: 'error',\n\n\t\t// any other event in this state shows this error\n\t\t'.*': function(cb, e) {\n\t\t\tconsole.log('error: i cant understand what you mean by \"' + e + '\"');\n\t\t\tcb();\n\t\t},\n\t},\n\n\trunning: {\n\n\t\t// animate clock every tick\n\t\ttick: function(cb) {\n\t\t\tvar clock = [ '|', '/', '-', '\\\\' ];\n\t\t\tprocess.stdout.write('(' + clock[tim._i] + \")\");\n\t\t\tfor (var i = 0; i < 50; ++i) process.stdout.write(' ');\n\t\t\tprocess.stdout.write('\\r');\n\t\t\ttim._i = (tim._i + 1) % clock.length;\n\t\t\tcb();\n\t\t},\n\n\t\t// cannot exit from this state\n\t\texit: 'error',\n\n\t\t// when 'no' or 'stop' or 'x' are pushed, move to 'stopping' and start\n\t\t// a 2sec timeout that emits 'elapsed' when elapsed (surpise!)\n\t\t'(no|stop|x)': function(cb) { \n\t\t\tprocess.stdout.write('stopping...\\n');\n\t\t\ttim.state = 'stopping';\n\t\t\ttim.timeout('stopped', 5000);\n\n\t\t\tcb();\n\t\t},\n\n\t\t$exit: function(cb) {\n\t\t\t// take some time before changing state.\n\t\t\tconsole.log('our running times are over.. give me 2 more seconds.');\n\t\t\tsetTimeout(cb, 2000);\n\t\t},\n\n\t},\n\n\tstopping: {\n\n\t\t// called when the stopping timer elapses. clears the \n\t\t// interval and changes state to 'idle'\n\t\tstopped: function(cb) {\n\t\t\tprocess.stdout.write('\\nall done.\\n');\n\t\t\tclearInterval(tim._timer);\n\t\t\ttim.state = 'idle';\n\t\t\tcb();\n\t\t},\n\n\t\t// a tick during stop operation, show dots\n\t\ttick: function(cb) {\n\t\t\tprocess.stdout.write(\".\");\n\t\t\tcb();\n\t\t},\n\n\t\texit: 'error',\n\n\t},\n\n\terror: function(cb, state) {\n\t\tconsole.log('An error occured in state', state);\n\t\ttim.state = state;\n\t\tcb();\n\t},\n\n\t_timer: null, // timer object to allow clearing the interval\n\t_i: 0, // animated clock\n});\n\ntim.on('end', function() {\n\tprocess.exit();\n});\n\ntim.on('error', function() {\n\tconsole.log('on-error');\n});\n\ntim.on('idle.start', function() {\n\tconsole.log(\"try 'go' the next time...\");\n});\n\nvar i = require('../lib/debugger')(tim, { verbose: false });\n```\n\nMore examples under `examples/`.\n\n## Lisence\n\nMIT",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/eladb/node-fsmjs/issues"
  },
  "_id": "fsmjs@0.2.1",
  "dist": {
    "shasum": "1c02c505c8c29a680763daa3dd4c3c871b4196db"
  },
  "_from": "fsmjs@",
  "_resolved": "https://registry.npmjs.org/fsmjs/-/fsmjs-0.2.1.tgz"
}
